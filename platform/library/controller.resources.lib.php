<?php	/* 		(mg)framework Version 5.0				Copyright (c) 1999-2011 eikonlexis LLC. All rights reserved.				This program is protected by copyright laws and international treaties.		Unauthorized reproduction or distribution of this program, or any 		portion thereof, may result in serious civil and criminal penalties.			Module 		Resource Controller	*/		# -------------------------------------------------------------------------------------------------------------------	# Constants Declaration			// path to resources	define("RESOURCES_PATH", "../resources");	// resource types	define("RESOURCES_CSS", "css");	define("RESOURCES_JS", "js");		define("RESOURCES_MINIFIED", ".min.");	define("RESOURCES_OPTIMIZED", ".opt");	define("RESOURCES_MOBILE", ".mobile.");	define("RESOURCES_DEFAULTPLATFORM", -1);			# -------------------------------------------------------------------------------------------------------------------	# (class) mgResources	# manages resources such as Stylesheets (CSS) and JavaScripts (JS) - used by the framework main controller	class mgResources {		# -------------------------------------------------------------------------------------------------------------------		# private		private $resources;  // container for resources		private $cache;		private $framework = false;		private $dynamic = false;		private $static = false;		private $staticdynamic = false;						# -------------------------------------------------------------------------------------------------------------------		# Constructor		public function __construct($cache = false, $default = false, $framework = false, $dynamic = false) {			// initialize			$this->flush();			// set cache			$this->cache = $cache;			// set framework			$this->framework = $framework;			// set dynamic			$this->dynamic = $dynamic;			// set default			if($default) {				$this->register($default);			}		}				# ---------------------------------------------------------------------------------------------------------------		# (public) flush, resets the buffer		public function flush() {			$this->resources = Array(RESOURCES_CSS=>Array(), RESOURCES_JS=>Array());		}				# ---------------------------------------------------------------------------------------------------------------		# (public) add, adds a dynamic resource		public function add($type, $content) {			$this->resources[$type][] = Array("type"=>$type, "content"=>$content);		}				# ---------------------------------------------------------------------------------------------------------------		# (public) asjs, adds content as javascript		public function asjs($content) {			$this->add(RESOURCES_JS, $content);		}				# ---------------------------------------------------------------------------------------------------------------		# (public) ascss, adds content as css		public function ascss($content) {			$this->add(RESOURCES_CSS, $content);		}				# ---------------------------------------------------------------------------------------------------------------		# (public) setdynamic,		public function setdynamic($b = true) {			$this->dynamic = $b;		}				# ---------------------------------------------------------------------------------------------------------------		# (public) setdynamic,		public function setstatic($params, $dynamic = false) {			$this->static = $params;			$this->staticdynamic = $dynamic;		}							# ---------------------------------------------------------------------------------------------------------------		# (public) register, register resource(s)		public function register($resources = false) {			// initialize			$result = "";			// check resources			if(!$resources) return;			// create resources			if(!is_array($resources)) $resources = Array($resources);			// initialize list			$list = Array();			// prepare resources			foreach($resources as $res) {				// check res				switch(true) {					// is already a directory					case is_dir($res): 						// read directory						$content = array_merge(Array($res), mgGetDirectoryFiles($res));						// cycle						foreach($content as $d) {							if(!in_array($d, $list)&&is_dir($d)) {								$list[] = $d; 							}						}						break;					// default					default: 						$res = explode(",", $res); 						foreach($res as $r) {							// check							if(mgIsCacheString($r)) {								$list[] = $r;							} else {								$fn = sprintf("%s%s/", defined("RESOURCES_DEFAULTPATH")?RESOURCES_DEFAULTPATH:$this->framework->personality->resourcepath, $r);								if(is_dir($fn)) $list[] = $fn;							}						}						break;				}			}			// cycle list			foreach($list as $directory) {				// test for cached				if(mgIsCacheString($directory)) {					// parse					$d = explode("/", mgRemoveCacheString($directory));					// test					if(count($d)==2) {						$this->resources[$d[1]][] = Array(							"type"=>$d[1], 							"content"=>mgCacheReadStored($d[0])						);					}				} else {					// retrieve directory					$content = mgGetDirectoryFiles($directory);					// parse content					foreach($content as $filename) {						// get suffix						$suffix = mgGetFileSuffix($filename);						// sanity check						if(file_exists($filename)&&isset($this->resources[$suffix])&&!isset($this->resources[$suffix][$filename])) {							// add resources and load it							$this->resources[$suffix][$filename] = Array(								"type"=>$suffix, 								"content"=>$this->__getfile($filename, $suffix),								"filename"=>$filename,								"platform"=>mgLeftString($filename, FRAMEWORK_RESOURCEPATH)							);						}					}				}			}			// return			return $result;		}		# ---------------------------------------------------------------------------------------------------------------		# (public) compilecached, compiles a resource and caches it		public function compilecached($type, $include = true) {			// initialize result			$result = "";			// sanity check			if(isset($this->resources[$type])) {				// merge files				$buffer = Array("", ""); 				// sort				$res = $this->__sortresources($this->resources[$type]);				// buld content				foreach($res as $fn=>$params) {					// get buffer					$cnt = trim(@$params["content"]);					// assign					if($this->static&&$this->staticdynamic&&!isset($params["filename"])) {						$buffer[1] .= $cnt;					} else {						$buffer[0] .= $cnt;					}				}				// prepare buffer				foreach($buffer as $index=>$buffercnt) {					if($this->framework) {						// find translators						preg_match_all(sprintf("/%s%s(.*?)%s/", TEMPLATE_FIELD_BEGIN, TEMPLATE_FIELD_TRANSLATE, TEMPLATE_FIELD_END), $buffercnt, $matches, PREG_PATTERN_ORDER);						// return result						foreach($matches[1] as $s) {							// replace translation							$buffercnt = str_replace(sprintf("%s%s%s%s", TEMPLATE_FIELD_BEGIN, TEMPLATE_FIELD_TRANSLATE, $s, TEMPLATE_FIELD_END), $this->framework->translate->_($s), $buffercnt);						}						// set localized						$buffercnt = str_replace(sprintf("%s%slocalized%s", TEMPLATE_FIELD_BEGIN, TEMPLATE_FIELD_ACTION, TEMPLATE_FIELD_END), LOCALIZED_PATH.$this->framework->localized, $buffercnt);						$buffercnt = str_replace(sprintf("%s%slanguage%s", TEMPLATE_FIELD_BEGIN, TEMPLATE_FIELD_ACTION, TEMPLATE_FIELD_END), $this->framework->localized, $buffercnt);						// set resource variables						foreach(Array("BASEPATH"=>BASEPATH) as $key=>$value) {							$buffercnt = str_replace(sprintf("%s%s%s", TEMPLATE_FIELD_BEGIN, $key, TEMPLATE_FIELD_END), $value, $buffercnt);						}					}					//optimize buffer					$buffercnt = $this->__optimize($buffercnt, $type);					// assign					$buffer[$index] = $buffercnt;				}				// register in cache				if($this->static) {					$usebuffer = strlen($buffer[0])!=0;					$usedynamicbuffer = strlen($buffer[1])!=0;					// store static part					if($usebuffer) {						$cacheid = $this->cache->store($this->static[$type], serialize(Array("buffer"=>$buffer[0], "type"=>$type)), CACHE_RESOURCES, defined("CACHE_TIMEOUT_RESOURCES")?CACHE_TIMEOUT_RESOURCES:CACHE_TIMEOUT);						$filename = sprintf("/%s/%s/%s", REQUEST_RESOURCES, REQUEST_CACHE, $this->static[$type]);						}					// store dynamic part					if($usedynamicbuffer) {						$dynamicid = $this->cache->writequery($type, serialize(Array("buffer"=>$buffer[1], "type"=>$type)), CACHE_RESOURCES, defined("CACHE_TIMEOUT_RESOURCES")?CACHE_TIMEOUT_RESOURCES:CACHE_TIMEOUT);						$dynamicfilename = sprintf("/%s/%s/%s", REQUEST_RESOURCES, REQUEST_CACHE, $dynamicid);						}				} else {					$usebuffer = strlen($buffer[0])!=0;					if($usebuffer) {						if($this->dynamic) {							$cacheid = $this->cache->write(serialize(Array("dynamic"=>$this->dynamic, "buffer"=>$buffer[0], "type"=>$type)), CACHE_RESOURCES, defined("CACHE_TIMEOUT_RESOURCES")?CACHE_TIMEOUT_RESOURCES:CACHE_TIMEOUT); 						} else {							$cacheid = $this->cache->writequery($type, serialize(Array("buffer"=>$buffer[0], "type"=>$type)), CACHE_RESOURCES, defined("CACHE_TIMEOUT_RESOURCES")?CACHE_TIMEOUT_RESOURCES:CACHE_TIMEOUT);						}						// create filenames						$filename = sprintf("/%s/%s/%s", REQUEST_RESOURCES, $this->dynamic?REQUEST_CACHEDYNAMIC:REQUEST_CACHE, $cacheid);						}				}				// format output html				switch($type) {					// css					case RESOURCES_CSS: 						if($usebuffer) {							$result = Tag("link", Array("rel"=>"stylesheet", "type"=>"text/css", "href"=>$filename), false, true)."\n";						}						if(isset($usedynamicbuffer)&&$usedynamicbuffer&&$this->static&&isset($dynamicfilename)) {							$result .= Tag("link", Array("rel"=>"stylesheet", "type"=>"text/css", "href"=>$dynamicfilename), false, true)."\n";						}						break;					// js					case RESOURCES_JS: 						// loading method						$lm = Array();						if(defined("JAVASCRIPT_LOADMETHOD")) {							$lm = Array(								JAVASCRIPT_LOADMETHOD => TAG_NOVALUE							);						}												// process						if($usebuffer) {							$result = Tag("script", array_merge($lm, Array("type"=>"text/javascript", "src"=>$filename)))."\n"; 						} 						if(isset($usedynamicbuffer)&&$usedynamicbuffer&&$this->static&&isset($dynamicfilename)) {								$result .= Tag("script", array_merge($lm, Array("type"=>"text/javascript", "src"=>$dynamicfilename)))."\n"; 						}						break;				}			}			// return result			return $result;		}				# ---------------------------------------------------------------------------------------------------------------		# (public) fromcache, returns a cached resource		public function fromcache($cacheid, $cleanup = true, $dynamic = false) {			// query object			if($this->dynamic || $dynamic) {				$resource = unserialize($this->cache->read($cacheid, CACHE_RESOURCES, $cleanup));			} else {				$resource = unserialize($this->cache->readquery($cacheid, CACHE_RESOURCES, $cleanup));			}			// sanity check			if(is_array($resource)) {				// get proper type				switch(@$resource["type"]) {					case RESOURCES_JS: $type = "text/javascript"; break;					case RESOURCES_CSS: $type = "text/css"; break;					default: return false;				}				$resource["type"] = $type;				return $resource;			}			// failed			return false;		}						# ---------------------------------------------------------------------------------------------------------------		# (public) fromdir, returns a file resource 		public function fromdir($location) {			// create location finder			$locations = Array(				sprintf("%s%s", mgTrailSlash(defined("RESOURCES_DEFAULTPATH")?RESOURCES_DEFAULTPATH:$this->framework->personality->resourcepath), $location),				sprintf("%s/jquery%s", mgTrailSlash(FRAMEWORK_RESOURCEPATH), $location),				sprintf("%s/platform%s", mgTrailSlash(FRAMEWORK_RESOURCEPATH), $location)			);						foreach($locations as $filename) {				// sanity check				if(file_exists($filename)) {					// get type					$type = mgGetMime($filename);					// return					return Array(						"filetime"=>filemtime($filename),						"buffer"=>$this->__getfile($filename, $type),						"type"=>$type					);				}			}			// failed			return false;		}						# ---------------------------------------------------------------------------------------------------------------		# (private) __optimize, optimizes a css/js content		private function __optimize($b, $type, $f = false) {			return $b;			// switch by type			switch($type) {				// (css)				case RESOURCES_CSS:					// remove comments					$b = preg_replace('!/\*[^*]*\*+([^/][^*]*\*+)*/!', '', $b);					// remove spaces, new lines, etc					$b = str_replace(array("\r\n","\r","\n","\t",'  ','    ','     '), '', $b);					// remove other spaces					$b = preg_replace(array('(( )+{)','({( )+)'), '{', $b);					$b = preg_replace(array('(( )+})','(}( )+)','(;( )*})'), '}', $b);					$b = preg_replace(array('(;( )+)','(( )+;)'), ';', $b);					break;				// (js)				case RESOURCES_JS:					// create js compiler					if($f === true) {						$b = mgJSMin::minify($b);					}					break;			}								// return buffer			return $b;						}				# ---------------------------------------------------------------------------------------------------------------		# (private) __getfile, loads a file		private function __getfile($filename, $type = false) {			// initialiaze			$result = false;			// check mobile			if(defined("RESOURCES_USEMOBILE")&&RESOURCES_USEMOBILE=="true"&&$this->framework->ismobile()) {				// mobile filename				$mfile = $this->__getfilenamefor($filename, RESOURCES_MOBILE);				// check if file exists				if(file_exists($mfile)) $filename = $mfile;			} else {				// detect mobile file and remove				if(strpos($filename, RESOURCES_MOBILE)!==false) return false;			}			// check optimized			if(IfAppVar("RESOURCES_USEOPTIMIZED", true)) {				$opt = $filename.RESOURCES_OPTIMIZED;				if(file_exists($opt)) {					$result = @file_get_contents($opt);				}			} 			// check normal file			if($result === false && file_exists($filename)) {				// check normal file				$result = @file_get_contents($filename);				// check				if($type !== false && defined("RESOURCES_OPTIMIZEONDEMAND")&&RESOURCES_OPTIMIZEONDEMAND=="true") {					// compile resource					$result = $this->__optimize($result, $type, true);					// store					@file_put_contents($filename.RESOURCES_OPTIMIZED, $result);				}			}			// return			return $result;					}				# ---------------------------------------------------------------------------------------------------------------		# (private) __getfilenamefor		private function __getfilenamefor($filename) {			$ext = mgGetFileSuffix($filename);			return sprintf("%s/%s%s%s",				dirname($filename),				basename($filename, ".".$ext),				RESOURCES_MOBILE,				$ext			);		}						# ---------------------------------------------------------------------------------------------------------------		# (private) __sortresources		private function __sortresources($resources) {			$result = Array();			foreach($resources as $fn=>$params) {				if(isset($params["platform"])&&$params["platform"]===true) {					$result[$fn] = $params;					unset($resources[$fn]);				}							};			return array_merge($result, $resources);		}	}