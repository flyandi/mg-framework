<?php	/* 		(mg)framework Version 5.0				Copyright (c) 1999-2011 eikonlexis LLC. All rights reserved.				This program is protected by copyright laws and international treaties.		Unauthorized reproduction or distribution of this program, or any 		portion thereof, may result in serious civil and criminal penalties.			Module 		Cache Controller	*/		# -------------------------------------------------------------------------------------------------------------------	# Constants Declaration			define("SESSIONCACHE", "@sessioncache");		// path to cached object	define("CACHE_PATH", "../../cache");	define("CACHE_MODE_FILE", "file");	define("CACHE_MODE_MEMORY", "memory");	// cache groups	define("CACHE_ANY", "default");	define("CACHE_RESOURCES", "resources");	define("CACHE_STORE", "store");	define("CACHE_PAGE", "page");	define("CACHE_NOCACHE", "nocache");	define("CACHE_MOBILE", "mobile://");		// cache control	define("CACHE_TIMEOUT_NONE", -1);	// none	define("CACHE_TIMEOUT", 120);		// 2 minutes	define("CACHE_TIMEOUT_PAGE", 3600 * 24 * 7); 	// 1 week		// other	define("CACHE_STRING", "cache:");	// status	define("CACHE_OK", 1);	define("CACHE_ERROR", 0);	define("CACHE_EXPIRED", -100);	define("CACHE_NOTEXISTS", -101);		// exceptions	define("CACHE_PAGE_DEFAULTEXCEPTION", "manager,signin,signup,logout,resources,api,assets,robots.txt,sitemap.xml,sitemap.xml.gz,favicon.png,favicon.ico");	define("CACHE_PAGE_FILE", "/page");	define("CACHE_PAGE_RESOURCES", "js,css");	define("CACHE_PAGE_COOKIE", "PTag");		# -------------------------------------------------------------------------------------------------------------------	# (class) mgCache	# provides low level function for caching (APC support)	class mgCache {			# -------------------------------------------------------------------------------------------------------------------		# (private)		private $mode = CACHE_MODE_FILE;		private $memcache = false;		private $memcached = false;				# -------------------------------------------------------------------------------------------------------------------		# Constructor		public function __construct() {			// check mode of chache			if(defined("CACHE_TYPE")) {				switch(strtolower(CACHE_TYPE)) {					// set memory cache					case CACHE_MODE_MEMORY: 						// get version						if(defined("CACHE_MEMCACHED")&&CACHE_MEMCACHED=="true") {							$this->memcached = true;						}						// initiate instance						if($this->memcached) {							$this->memcache = new Memcached();						} else {							$this->memcache = new Memcache();						}						// get application						$app = GetVar(APPLICATION);						// get list of memcache servers						$s = 0;						foreach(@$app->xml->memcacheservers->Children() as $child) {							// add server							if($this->memcache->addserver(								(string)$child["host"], 								(integer)$child["port"],								isset($child["weight"])&&(string)$child["weight"]!="false"?(integer)$child["weight"]:0							)) {								$s += 1;							}						}						// set mode						if($s>0) {							$this->mode = CACHE_MODE_MEMORY;						}						break;				}			}		}				# -------------------------------------------------------------------------------------------------------------------		# (public) clear, clears the cache		public function clear($cache = false) {			// get directories and files			mgDeleteDirectory(sprintf("%s/%s", $cache?CACHE_PATH:sprintf("%s/%s", CACHE_PATH, $cache), APPLICATION_ID), false);		}				# -------------------------------------------------------------------------------------------------------------------		# (public) read, reads an cached item 		public function read($cacheid, $cache = CACHE_ANY, $cleanup = false, $default = "", $timeout = false) {			// initialze result			$result = $default;			// switch by mode			switch($this->mode) {				// (memory)				case CACHE_MODE_MEMORY: 					// create id					$id = sprintf("%s-%s-%s", APPLICATION_ID, $cache, $cacheid);					// get cache					$b = $this->memcache->get($id);					// check buffer					if($b!==false) {						// read key						$result = unserialize($b);						// cleanup						if($cleanup&&$timeout===false) {							// remove reference							$this->memcache->delete($id);						}						break;					}				// (file) default				default:					// create filename					$filename = sprintf("%s/%s/%s/%s", CACHE_PATH, APPLICATION_ID, $cache, $cacheid);					// sanity check					if(file_exists($filename)) {						// get result						$result = file_get_contents($filename);						// check timestamp						if($timeout!==false) {							$cleanup = mgIsFileExpired($filename, $timeout);						}						// check delete (quick clean up)						if($cleanup) {							@unlink($filename);						} else {							// set etag							SetVar(ETAG, md5(filemtime($filename)));						}					}					break;			}			// return result			return $result;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) write, writes an item to the cache and returns the cache id		public function write($buffer, $cache = CACHE_ANY, $timeout = CACHE_TIMEOUT_NONE) {			// create cache id			$cacheid = sprintf("%s", CreateGUID());			// store to cache			mgCache::store($cacheid, $buffer, $cache, $timeout);			// return id			return $cacheid;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) store,		public function store($id, $buffer, $cache = CACHE_STORE, $timeout = CACHE_TIMEOUT_NONE) {			// initialize			$path = false;			// switch by mode			switch($this->mode) {				// (memory)				case CACHE_MODE_MEMORY: 					// create id					$path = sprintf("%s-%s-%s", APPLICATION_ID, $cache, $id);					// write to memory					$wm = false;					if($this->memcached) {						$wm = $this->memcache->add($path, serialize($buffer), $timeout==CACHE_TIMEOUT_NONE?0:(time()+$timeout));					} else {						$wm = $this->memcache->add($path, serialize($buffer), defined("MEMCACHE_COMPRESSED")&&MEMCACHE_COMPRESSED=="true"?CACHE_MEMCACHE_COMPRESS:false, $timeout);					}					// result					if($wm) {						// stop here, otherwise we will write to the file cache as alternatives						break;					}									// (file) default				default:					// create cache filename					$path = sprintf("%s/%s/%s/%s", CACHE_PATH, APPLICATION_ID, $cache, $id);					// create dynamic directory					@mkdir(dirname($path), 0777, true);					// write cache					@file_put_contents($path, $buffer);							break;			}						// return path			return $path;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) remove,		public function remove($id, $cache = CACHE_STORE) {			// initialize			$result = false;			// switch by mode			switch($this->mode) {				// (memory)				case CACHE_MODE_MEMORY: 					// create id					$path = sprintf("%s-%s-%s", APPLICATION_ID, $cache, $id);					// remove					$result = $this->memcache->delete($path);					// result					if($result) {						// stop here, otherwise we will write to the file cache as alternatives						break;					}									// (file) default				default:					// create cache filename					$path = sprintf("%s/%s/%s/%s", CACHE_PATH, APPLICATION_ID, $cache, $id);					// create dynamic directory					if(file_exists($path)) $result = @unlink($path);					break;			}						// return path			return $result;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) exists		public function exists($id, $cache = CACHE_STORE) {			// initialize			$result = false;			// switch by mode			switch($this->mode) {				// (memory)				case CACHE_MODE_MEMORY: 					// create id					$path = sprintf("%s-%s-%s", APPLICATION_ID, $cache, $id);					// check					if($this->memcached) {						$wm = $this->memcache->append($path, null);					} else {						$wm = $this->memcache->add($path);						if($wm===true) {							$wm = false;							$this->memcache->delete($path);						}					}					// result					if($result) {						// stop here, otherwise we will write to the file cache as alternatives						break;					}									// (file) default				default:					// create cache filename					$path = sprintf("%s/%s/%s/%s", CACHE_PATH, APPLICATION_ID, $cache, $id);					// create dynamic directory					$result = file_exists($path);					break;			}						// return path			return $result;		}						# -------------------------------------------------------------------------------------------------------------------		# (public) filename		public function filename($id, $cache = CACHE_ANY) {			return sprintf("%s/%s/%s/%s", CACHE_PATH, APPLICATION_ID, $cache, $id);		}				# -------------------------------------------------------------------------------------------------------------------		# (public) rwritequery		public function writequery($query, $buffer, $cache = CACHE_ANY, $timeout = CACHE_TIMEOUT_NONE) {			// create cacheid			$cacheid = mgHasPageCache()?mgCreatePageCacheId($query):md5($query.$cache);			// store to cache			mgCache::store($cacheid, $buffer, $cache, mgHasPageCache()?mgPageCacheTimeout():$timeout);			// return id			return $cacheid;		}			# -------------------------------------------------------------------------------------------------------------------		# (public) rwritequery		public function readquery($cacheid, $cache = CACHE_ANY, $cleanup = false) {			return $this->read($cacheid, $cache, $cleanup, false, mgHasPageCache()?mgPageCacheTimeout():CACHE_TIMEOUT_NONE);		}					# -------------------------------------------------------------------------------------------------------------------		# (public) page - page cache		public function page($content = false, $timeout = false, $id = false, $verbose = false) {			// create request id			$request =  GetServerVar("REQUEST_URI", false);			// check request			if($request===false||GetVar(CACHE_NOCACHE)===true) return false;			// determinate exceptions			$exp = array_merge(explode(",", CACHE_PAGE_DEFAULTEXCEPTION),  AppVar("CACHE_PAGECACHEEXCLUDE")?explode(",", CACHE_PAGECACHEEXCLUDE):Array());			// test exception			if(in_array(GetDirVar(0), $exp)) return false;			// build id			$id = $id?$id:mgCreatePageCacheId();			// timeout			$timeout = $timeout?$timeout:mgPageCacheTimeout();			// process			if($content === false) {				// read				$content = $this->Read($id, CACHE_PAGE, false, false, $timeout);				// verbose				if($content && $verbose) {					$content = Tag("div", Array("style"=>"border:3px solid red;background:black;color:red;padding:1em;font:15px sans-serif;"), sprintf("<em>Cached Page</em> <strong>Id</strong> %s <strong>Path</strong> %s", 						mgCreatePageCacheId(),						GetServerVar("REQUEST_URI").GetServerVar("QUERY_STRING")					)).$content;				}				if ($content) {					// add caching meta tag always					$content = str_replace("</head>", sprintf("%s</head>", Tag("meta", Array("property"=>"cache", "value"=>$id), false, true)), $content);				}				// return data				return $content;			} else {				// store				return $this->Store($id, $content, CACHE_PAGE, $timeout);			}			return false;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) pageresources		function pageresources($resources = CACHE_PAGE_RESOURCES) {			foreach(explode(",", $resources) as $id) {				if(!$this->exists(mgCreatePageCacheId($id), CACHE_RESOURCES)) return false;			}			return true;		}				# -------------------------------------------------------------------------------------------------------------------		# (public) removepage		function removepage($id = false) {			if($id === false) {				$id = md5(GetServerVar("REQUEST_URI").GetServerVar("QUERY_STRING"));			}			// delete			return $this->remove($id, CACHE_PAGE);		}				# -------------------------------------------------------------------------------------------------------------------		# (public) invalidate		function invalidate($request = false) {			return $this->removepage(md5($request));		}			}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCacheRead	function mgCacheRead($id, $cache = CACHE_ANY, $cleanup = false, $default = false, $timeout = false) {		// create cache		$c = new mgCache();		// return		return $c->read($id, $cache, $cleanup, $default, $timeout);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCacheWrite	function mgCacheWrite($buffer, $cache = CACHE_ANY, $timeout = CACHE_TIMEOUT_NONE) {		// create cache		$c = new mgCache();		// return		return $c->write($buffer, $cache, $timeout);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCacheStore	function mgCacheStore($id, $buffer, $cache = CACHE_ANY, $timeout = CACHE_TIMEOUT_NONE) {		// create cache		$c = new mgCache();		// return		return $c->store($id, $buffer, $cache, $timeout);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCacheReadStored	function mgCacheReadStored($id, $default = false) {		// create cache		$c = new mgCache();		// returm		return $c->read($id, CACHE_STORE, false, $default);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCacheFilename	function mgCacheFilename($id, $cache=CACHE_ANY) {		return mgCache::filename($id, $cache);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgIsCacheString	function mgIsCacheString($s) {		return substr(strtolower($s), 0, strlen(CACHE_STRING))==CACHE_STRING;	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgRemoveCacheString	function mgRemoveCacheString($s) {		return substr($s, strlen(CACHE_STRING));	}			# -------------------------------------------------------------------------------------------------------------------	# (macro) mgSessionCacheRead	function mgSessionCacheRead($id, $default = null) {		// get cache		$cache = GetVar(SESSIONCACHE, Array());		// check if exists		return is_array($cache)&&isset($cache[$id])?$cache[$id]:$default;	}	# -------------------------------------------------------------------------------------------------------------------	# (macro) mgSessionCacheWrite	function mgSessionCacheWrite($id, $data) {		// get cache		$cache = GetVar(SESSIONCACHE, Array());		// verify cache		if(!is_array($cache)) $cache = Array();		// set value		$cache[$id] = $data;		// set cache		SetVar(SESSIONCACHE, $cache);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgSessionCacheQuery	function mgSessionCacheQuery($id, $setvalue = false) {		// get tmp id		$tmpid = CreateGUID();		// get value		$value = mgSessionCacheRead($id, $tmpid);		// check value		if($value == $tmpid && $setvalue !== false) {			// initialize			$value = false;			// create value			if(is_callable($setvalue)) {				// get value				$value = $setvalue();			} else {				$value = $setvalue;			}			// check 			if($value !== false) {				mgSessionCacheWrite($id, $value);			}		}		// return value		return $value;	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgHasPageCache	function mgHasPageCache() {		return IfAppVar("CACHE_PAGECACHE", true); // && GetVar(CACHE_NOCACHE, false)===true;	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgCreatePageCacheId	function mgCreatePageCacheId($append = false, $prepend = false) {		return sprintf("%s%s%s", 			$append?$append:"",			md5(sprintf("%s%s%s", 				IfAppVar("CACHE_PAGECACHEMOBILE", true)&&mgIsMobileBrowser()?CACHE_MOBILE:"",				GetServerVar("REQUEST_URI"),				GetServerVar("QUERY_STRING")			)),			$prepend?$prepend:""		);	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgPageCacheTimeout	function mgPageCacheTimeout() {		return defined("CACHE_PAGECACHETIMEOUT")?CACHE_PAGECACHETIMEOUT:CACHE_TIMEOUT_PAGE;	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgPageCacheIsSecureCookie	function mgPageCacheIsSecureCookie() {		// retrieve value		$s = GetVar(CACHE_PAGE_COOKIE, false);		// check		return $s == md5(GetRemoteAddress());	}		# -------------------------------------------------------------------------------------------------------------------	# (macro) mgPageCacheSetCookie	function mgPageCacheSetCookie($secured = false) {		// retrieve value		@setcookie(CACHE_PAGE_COOKIE, $secured?md5(GetRemoteAddress()):CreateGUID(), time() + AppVar("CACHE_PAGECACHEMANAGERTIMEOUT", 3600), "/", BASEPATH, false, true);	}			?>